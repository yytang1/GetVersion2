package GetVersion;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Row;

public class VulnerabilityInfo {

    ExcelUtil excelUtil = new ExcelUtil();

    public static class VulnerInfo {
        public String cve = ""; // cve号
        public String softeware = ""; // 软件名
        public String softwareVersion = ""; // 含漏洞软件版本
        public String fileName = ""; // 漏洞文件名
        public String functionName = ""; // 漏洞函数名
        public ArrayList<String> versionUsed = new ArrayList<String>();// 表格中的Version
                                                                       // Used，选取的含漏洞的软件版本

        public ArrayList<String> containVersions = new ArrayList<String>(); // 检查后包含漏洞的版本
        public ArrayList<String> errorVersions = new ArrayList<String>(); // 版本漏洞已经修改
        public ArrayList<String> existVersions = new ArrayList<String>(); // 文件存在的版本
        public ArrayList<String> reuseVersions = new ArrayList<String>(); // 漏洞复用代码示例
        public ArrayList<String> reuseVersionsMost = new ArrayList<String>(); // 最大匹配行漏洞复用代码示例

        public String report = "";// 提示说明
    }

    /**
     * 从excel中读取
     * 
     * @param filePath
     *            excel路径
     * @return 预置数据信息数组，不正确时返回{@code null}
     * @throws InvalidFormatException
     */
    public ArrayList<VulnerInfo> readInfoFromExcel(String filePath) throws InvalidFormatException {
        ArrayList<VulnerInfo> vulnerInfos = new ArrayList<VulnerInfo>();
        if (filePath == null) {
            return vulnerInfos;
        }
        ArrayList<Row> rows = excelUtil.readExcelHssfRows(filePath, 0);
        if (rows.size() == 0) {
            return vulnerInfos;
        }
        rows.remove(0);
        for (Row row : rows) {
            String temp = excelUtil.getCellStringValue(row, 0);
            if (temp == null || temp.length() < 1) {
                continue;
            }
            VulnerInfo vulnerInfo = new VulnerInfo();

            vulnerInfo.cve = excelUtil.getCellStringValue(row, 0).replaceAll("[ |　]", " ")
                    .replaceAll("\\u00A0", "").trim();
            vulnerInfo.softeware = excelUtil.getCellStringValue(row, 2).replaceAll("[ |　]", " ")
                    .replaceAll("\\u00A0", "").trim().toLowerCase();
            if (vulnerInfo.softeware.equals("linux_kernel")) {
                vulnerInfo.softeware = "linux";
            }
            vulnerInfo.softwareVersion = excelUtil.getCellStringValue(row, 3)
                    .replaceAll("[ |　]", " ").replaceAll("\\u00A0", "").trim();

            String fileName = excelUtil.getCellStringValue(row, 4);
            if (fileName == null) {
                vulnerInfo.report += "漏洞文件名为空，请注意查看";
                vulnerInfos.add(vulnerInfo);
                continue;
            }
            fileName = fileName.replaceAll("[ |　]", " ").replaceAll("\\u00A0", "").trim();
            vulnerInfo.fileName = fileName;
            System.out.println(fileName);
            String[] fileList = fileName.split("[;；]");

            String functionName = excelUtil.getCellStringValue(row, 5);
            if (functionName != null) {
                String[] functionList = functionName.split("[;；]");
                if (functionList.length < fileList.length) {
                    vulnerInfo.report += "漏洞文件名和漏洞函数不匹配，请注意查看";
                    vulnerInfos.add(vulnerInfo);
                    continue;
                }
                vulnerInfo.functionName = functionName.replaceAll("\\u00A0", "").trim();
            } else {
                vulnerInfo.functionName = functionName;
            }
            vulnerInfos.add(vulnerInfo);
        }
        return vulnerInfos;
    }

    void reuseResultToExcel(String excelPath, ArrayList<String> reuseList) {
        HSSFWorkbook workbook = new HSSFWorkbook();
        HSSFCellStyle cellStyle = workbook.createCellStyle();
        HSSFSheet sheet = workbook.createSheet();
        // 初始化纵向对齐方式为居中
        cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
        // 初始化单元格大小为包含文本
        cellStyle.setWrapText(true);
        // 初始化工作表的列宽
        sheet.setColumnWidth(0, 80 * 256);

        for (int rowIndex = 0; rowIndex < reuseList.size() + 1; rowIndex++) {
            HSSFRow row = sheet.createRow(rowIndex);
            HSSFCell cell = row.createCell(0);
            if (rowIndex == 0) {
                cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
            } else {
                cellStyle.setAlignment(HSSFCellStyle.ALIGN_LEFT);
            }
            cell.setCellStyle(cellStyle);
            cell.setCellValue(rowIndex == 0 ? "CVE号_软件名版本号_函数名" : reuseList.get(rowIndex - 1));
        }

        try {
            String path = excelPath.substring(0, excelPath.lastIndexOf("\\") + 1);
            String name = excelPath.substring(excelPath.lastIndexOf("\\") + 1);
            if (name.contains(".xlsx")) {
                name = name.replace(".xlsx", "复用列表结果总汇.xls");
            } else {
                name = name.replace(".xls", "复用列表结果总汇.xls");
            }
            new File(path).mkdirs();
            workbook.write(new FileOutputStream(path + name));
            workbook.close();
            System.out.println(path + name);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }

    /**
     * 初始化一个结果展示的Excel,并创建一个单元格样式,初始化基本值
     * 
     * @param workbook
     *            初始化的Excel
     * @return 返回创建的单元格样式{@link HSSFCellStyle}
     */
    private HSSFCellStyle initWorkbook(HSSFWorkbook workbook) {
        HSSFCellStyle cellStyle = workbook.createCellStyle();
        HSSFSheet sheet = workbook.createSheet();
        // 初始化纵向对齐方式为居中
        cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
        // 初始化单元格大小为包含文本
        cellStyle.setWrapText(true);
        // 初始化工作表的列宽
        sheet.setColumnWidth(0, 15 * 256);
        sheet.setColumnWidth(1, 15 * 256);
        sheet.setColumnWidth(2, 15 * 256);
        sheet.setColumnWidth(3, 25 * 256);
        sheet.setColumnWidth(4, 25 * 256);
        sheet.setColumnWidth(5, 40 * 256);
        sheet.setColumnWidth(6, 40 * 256);
        sheet.setColumnWidth(7, 30 * 256);
        sheet.setColumnWidth(8, 30 * 256);
        sheet.setColumnWidth(9, 30 * 256);
        return cellStyle;
    }

    /***
     * 
     * @param vulnerInfos
     * @param excelPath
     *            结果表格路径地址
     */
    public void writeResultToExcel(ArrayList<VulnerInfo> vulnerInfos, String excelPath) {
        HSSFWorkbook workbook = new HSSFWorkbook();
        HSSFCellStyle cellStyle = initWorkbook(workbook);
        HSSFSheet sheet = workbook.getSheetAt(0);
        for (int rowIndex = 0; rowIndex < vulnerInfos.size() + 1; rowIndex++) {
            VulnerInfo vulnerInfo = rowIndex == 0 ? null : vulnerInfos.get(rowIndex - 1);
            HSSFRow row = sheet.createRow(rowIndex);
            HSSFCell cell = null;
            for (int i = 0; i < 10; i++) {
                cell = row.createCell(i);
                if (rowIndex == 0) {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
                } else {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_LEFT);
                }
                cell.setCellStyle(cellStyle);
                switch (i) {
                case 0:
                    cell.setCellValue(rowIndex == 0 ? "CVE ID" : vulnerInfo.cve);
                    break;
                case 1:
                    cell.setCellValue(rowIndex == 0 ? "Software" : vulnerInfo.softeware);
                    break;
                case 2:
                    cell.setCellValue(rowIndex == 0 ? "Software version"
                            : vulnerInfo.softwareVersion);
                    break;
                case 3:
                    cell.setCellValue(rowIndex == 0 ? "漏洞文件名" : vulnerInfo.fileName);
                    break;
                case 4:
                    cell.setCellValue(rowIndex == 0 ? "漏洞函数名" : vulnerInfo.functionName);
                    break;
                case 5:
                    cell.setCellValue(rowIndex == 0 ? "Version Used" : (vulnerInfo.containVersions
                            .size() > 0 ? vulnerInfo.containVersions.get(0) : ""));
                    break;
                case 6:
                    cell.setCellValue(rowIndex == 0 ? "含漏洞软件版本" : (vulnerInfo.containVersions
                            .toString()));
                    break;
                case 7:
                    cell.setCellValue(rowIndex == 0 ? "漏洞已经修复过版本" : (vulnerInfo.errorVersions
                            .toString()));
                    break;
                case 8:
                    cell.setCellValue(rowIndex == 0 ? "补充说明" : vulnerInfo.report);
                    break;
                case 9:
                    cell.setCellValue(rowIndex == 0 ? "复用代码示例列表" : (vulnerInfo.reuseVersionsMost
                            .toString()));
                    break;
                default:
                    break;
                }
            }
        }
        try {
            String path = excelPath.substring(0, excelPath.lastIndexOf("\\") + 1);
            String name = excelPath.substring(excelPath.lastIndexOf("\\") + 1);
            if (name.contains(".xlsx")) {
                name = name.replace(".xlsx", "result.xls");
            } else {
                name = name.replace(".xls", "result.xls");
            }
            new File(path).mkdirs();
            workbook.write(new FileOutputStream(path + name));
            workbook.close();
            System.out.println(path + name);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }

    public static void main(String[] args) throws InvalidFormatException {
        // TODO Auto-generated method stub
        // String excelPath =
        // "C:\\Users\\wt\\Desktop\\tyy\\实验室work-tyy\\getContainVersion\\testTemp.xls";

        // String excelPath1 =
        // "C:\\Users\\wt\\Desktop\\tyy\\实验室work-tyy\\getContainVersion\\test.xlsx";
        String excelPath2 = "C:\\Users\\wt\\Desktop\\tyy\\实验室work-tyy\\getContainVersion\\2016.1.26-Ffmpeg漏洞信息-上传服务器-GetVersion.xls";
        String excelPath3 = "C:\\Users\\wt\\Desktop\\tyy\\实验室work-tyy\\getContainVersion\\2016.1.26-Ffmpeg漏洞信息-上传服务器-GetVersion-Temp.xls";
        VulnerabilityInfo vulnerabilityInfo = new VulnerabilityInfo();
        ArrayList<VulnerInfo> vulnerInfos = vulnerabilityInfo.readInfoFromExcel(excelPath2);

        for (VulnerInfo vulnerInfo : vulnerInfos) {
            System.out.println(vulnerInfo.softeware);
            System.out.println(vulnerInfo.cve + "\t" + vulnerInfo.softeware + "\t"
                    + vulnerInfo.softwareVersion + "\t" + vulnerInfo.fileName + "\t"
                    + vulnerInfo.functionName);
            vulnerInfo.containVersions.add("2.5.6");
            vulnerInfo.containVersions.add("2.4.6");
            vulnerInfo.containVersions.add("2.3.6");
        }
        System.out.println("总数：" + vulnerInfos.size());
        vulnerabilityInfo.writeResultToExcel(vulnerInfos, excelPath3);
    }
}
